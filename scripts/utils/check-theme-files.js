const Diff = require('diff');
const Promise = require('bluebird');
const dayjs = require('dayjs');
const path = require('path');
const fs = require('fs-extra');
const cliProgress = require('cli-progress');

const { log } = require('../helpers');
const { shopifyAPI } = require('./api');
const {
  paths: { srcDir },
  ignoreFiles,
  themeId
} = require('../../app.config');

function getRawData(data) {
  let rawData = null;
  if (data.attachment) {
    rawData = Buffer.from(data.attachment, 'base64');
  } else if (data.value) {
    rawData = Buffer.from(data.value, 'utf8');
  }

  return rawData;
}

async function getAssetDataByKey(key) {
  const data = await shopifyAPI.asset.get(themeId, {
    'asset[key]': key
  });

  if (data.value === 'null') {
    return null;
  }

  return data;
}

function skipFile(key) {
  let shouldSkip = false;
  // do not count scss|svg file generated by Shopify server
  if (/assets\/.+\.(scss|svg)$/.test(key)) {
    const liquidFileExists = fs.existsSync(
      path.join(`${srcDir}`, `${key}.liquid`)
    );
    if (liquidFileExists) {
      shouldSkip = true;
    }
  }

  // do not count files generated by build (e.g. `scss` file from `scss.liquid` file)
  if (
    ignoreFiles.download.some((ignorePattern) => {
      const regexPattern = /^\/|\/$/g;
      const matches = regexPattern.exec(ignorePattern);
      if (matches) {
        return new RegExp(ignorePattern.replace(regexPattern, '')).test(key);
      }
      // TODO: handle glob pattern
      return false;
    })
  ) {
    shouldSkip = true;
  }

  return shouldSkip;
}

function getJSONString(buffer) {
  return JSON.stringify(JSON.parse(buffer.toString('utf8')), null, 2);
}

function toString(buffer, data) {
  if (data.content_type === 'application/json') {
    return getJSONString(buffer);
  }

  return buffer.toString('utf8');
}

async function checkThemeFiles(options = {}) {
  const { files, debug = false, concurrency = 1 } = options;

  const showProgress = !debug;

  log.info(`Checking files with concurrency: ${concurrency}`);
  log.info(`Checking env: ${process.env.ENV_PREFIX}`);

  const progressBar =
    showProgress &&
    new cliProgress.SingleBar(
      {
        format:
          '[{bar}] {percentage}% | ETA: {eta}s | {value}/{total} | {filePath}'
      },
      cliProgress.Presets.shades_classic
    );

  try {
    let assets = await shopifyAPI.asset.list(themeId);
    // filter assets
    if (Array.isArray(files)) {
      assets = assets.filter(({ key }) => files.includes(key));
    } else {
      assets = assets.filter(({ key }) => !skipFile(key));
    }
    progressBar && progressBar.start(assets.length, 0, { filePath: '' });

    // `index` value is not returning in order, so define `count` manually
    let count = 0;
    const result = await Promise.map(
      assets,
      async function checkAsset(asset) {
        count++;
        const key = asset.key;
        const filePath = `${srcDir}/${key}`;
        let fileExists = true;
        let stat;
        let assetData;

        progressBar &&
          progressBar.update(count, {
            filePath
          });

        try {
          stat = await fs.stat(path.resolve(filePath));
        } catch (err) {
          if (err.code === 'ENOENT') {
            fileExists = false;
          }
        }

        const localMtime = stat && dayjs(stat.mtime).toDate();
        const remoteMtime = dayjs(asset.updated_at).toDate();
        let localSize = stat && stat.size;
        let remoteSize = asset.size;

        let patchText;

        if (fileExists) {
          assetData = await getAssetDataByKey(key);
          if (!assetData) {
            return;
          }

          const localFile = await fs.readFile(path.resolve(`${filePath}`));
          const remoteFile = getRawData(assetData);

          let isEqual = localFile.equals(remoteFile);
          // Shopify reports the file size for JSON w/o white spaces but returns content with white spaces
          if (asset.content_type === 'application/json') {
            const localJSONString = getJSONString(localFile);
            const remoteJSONString = getJSONString(remoteFile);
            localSize = localJSONString.length;
            remoteSize = remoteJSONString.length;
            isEqual = localJSONString === remoteJSONString;
          }

          if (debug) {
            log(
              `${key} (localMtime: ${dayjs(localMtime).format(
                'MM-DDTHH:mm:ss'
              )}, localSize: ${localSize}) (remoteMtime: ${dayjs(
                remoteMtime
              ).format('MM-DDTHH:mm:ss')}, remoteSize: ${remoteSize})`
            );
          }

          if (isEqual) {
            return;
          }

          // check diff only for text file
          if (assetData.value) {
            const localText = toString(localFile, assetData);
            const remoteText = toString(remoteFile, assetData);
            patchText = Diff.createPatch(
              key,
              remoteText,
              localText,
              'remote',
              'local'
            );
          }
        }

        const result = {
          asset: {
            ...asset,
            localMtime:
              localMtime && dayjs(localMtime).format('MM-DDTHH:mm:ss'),
            remoteMtime: dayjs(remoteMtime).format('MM-DDTHH:mm:ss'),
            localSize,
            remoteSize
          },
          patchText
        };

        return result;
      },
      { concurrency }
    );

    // Filter out `undefined` value within the map that's set by the iteration which short circuits with `return` statement.
    return result.filter(Boolean);
  } catch (err) {
    throw new Error(err);
  } finally {
    progressBar && progressBar.stop();
  }
}

module.exports = checkThemeFiles;
